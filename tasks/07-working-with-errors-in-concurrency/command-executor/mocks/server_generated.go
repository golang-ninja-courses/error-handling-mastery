// Code generated by MockGen. DO NOT EDIT.
// Source: server.go

// Package commandexecutormocks is a generated GoMock package.
package commandexecutormocks

import (
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"

	commandexecutor "github.com/golang-ninja-courses/error-handling-mastery/tasks/07-working-with-errors-in-concurrency/command-executor"
)

// MockICmdExecutor is a mock of ICmdExecutor interface.
type MockICmdExecutor struct {
	ctrl     *gomock.Controller
	recorder *MockICmdExecutorMockRecorder
}

// MockICmdExecutorMockRecorder is the mock recorder for MockICmdExecutor.
type MockICmdExecutorMockRecorder struct {
	mock *MockICmdExecutor
}

// NewMockICmdExecutor creates a new mock instance.
func NewMockICmdExecutor(ctrl *gomock.Controller) *MockICmdExecutor {
	mock := &MockICmdExecutor{ctrl: ctrl}
	mock.recorder = &MockICmdExecutorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockICmdExecutor) EXPECT() *MockICmdExecutorMockRecorder {
	return m.recorder
}

// Exec mocks base method.
func (m *MockICmdExecutor) Exec(cid commandexecutor.CommandID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exec", cid)
	ret0, _ := ret[0].(error)
	return ret0
}

// Exec indicates an expected call of Exec.
func (mr *MockICmdExecutorMockRecorder) Exec(cid interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockICmdExecutor)(nil).Exec), cid)
}

// ResultsCh mocks base method.
func (m *MockICmdExecutor) ResultsCh() <-chan commandexecutor.CommandResult {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ResultsCh")
	ret0, _ := ret[0].(<-chan commandexecutor.CommandResult)
	return ret0
}

// ResultsCh indicates an expected call of ResultsCh.
func (mr *MockICmdExecutorMockRecorder) ResultsCh() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResultsCh", reflect.TypeOf((*MockICmdExecutor)(nil).ResultsCh))
}

// MockIMetricsCollector is a mock of IMetricsCollector interface.
type MockIMetricsCollector struct {
	ctrl     *gomock.Controller
	recorder *MockIMetricsCollectorMockRecorder
}

// MockIMetricsCollectorMockRecorder is the mock recorder for MockIMetricsCollector.
type MockIMetricsCollectorMockRecorder struct {
	mock *MockIMetricsCollector
}

// NewMockIMetricsCollector creates a new mock instance.
func NewMockIMetricsCollector(ctrl *gomock.Controller) *MockIMetricsCollector {
	mock := &MockIMetricsCollector{ctrl: ctrl}
	mock.recorder = &MockIMetricsCollectorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIMetricsCollector) EXPECT() *MockIMetricsCollectorMockRecorder {
	return m.recorder
}

// CountCommand mocks base method.
func (m *MockIMetricsCollector) CountCommand(cid commandexecutor.CommandID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CountCommand", cid)
	ret0, _ := ret[0].(error)
	return ret0
}

// CountCommand indicates an expected call of CountCommand.
func (mr *MockIMetricsCollectorMockRecorder) CountCommand(cid interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountCommand", reflect.TypeOf((*MockIMetricsCollector)(nil).CountCommand), cid)
}

// CountError mocks base method.
func (m *MockIMetricsCollector) CountError(err error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CountError", err)
	ret0, _ := ret[0].(error)
	return ret0
}

// CountError indicates an expected call of CountError.
func (mr *MockIMetricsCollectorMockRecorder) CountError(err interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountError", reflect.TypeOf((*MockIMetricsCollector)(nil).CountError), err)
}
